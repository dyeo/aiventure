import re

sentence_ends = [r'\.', r'\!', r'\?', r'"[^"]+"']
quote_classes = {'"': '“”', '\'': '`’'}


def get_last_sentence_end(text: str) -> int:
    """
    Finds the last sentence end in a given piece of text.

    :param text: The text to search.
    :return: The index of the last character in the last sentence end in the given text.
    """
    end = -1
    for e in sentence_ends:
        p_end = [m.end() for m in re.finditer(e, text)]
        end = max(end, p_end[-1] if len(p_end) > 0 else -1)
    return end


def remove_sentence_fragment(text: str) -> str:
    """
    Removes any dangling or incomplete sentences at the end of the given text.

    :param text: The text to process.
    :return: The processed text.
    """
    end = get_last_sentence_end(text)
    return text[:end + 1]


def formalize_quotes(text: str) -> str:
    """
    Ensures that all quotes used in a given text conform to the same type.

    :param text: The text to process.
    :return: The processed text.
    """
    for q, p in quote_classes.items():
        for c in p:
            text = re.sub(c, q, text)
    return text


def fix_end_quote(text: str, pre: str = ''):
    """
    Adds an ending quotation mark to the text if it wasn't generated by the AI.

    :param text: The text to process.
    :param pre: An optional prefix string to account for when counting quotes.
    :return: The processed text.
    """
    return (text + '"') if (pre + text).count('"') % 2 != 0 else text


def clean_white_space(text: str):
    """
    Cleans up whitespace.

    :param text: The text to process.
    :return: The processed text.
    """
    return re.sub(r' +', ' ', text)
